DESCRIPTION OF TEST CODE:
ADDU/SUBU:
6 lines generate random 16 bit numbers to assign to registers
Next 26 lines take ADDU and SUBU and applies on the first 7 assigned registers. Edge cases such as when both registers are the same are accounted for, but no data hazards will occur
Next 26 lines are in the form ADDU/SUBU $n, $(n-1), $(n-2). This will test for MEM/WB and EX/MEM data hazards INDEPENDENTLY
Register outputs are checked with MIPS interpreter
Next 26 lines are in the form ADDU/SUBU $n, $n, $register(1-6). This will test for when MEM/WB and EX/MEM data hazards both occur, in which case the value from EX/MEM should be taken
Register n is checked after all instructions are run

LUI:
31 Lines generate a random 16-bit uint. Saves LUI operated number in new register each time to be checked with MIPS interpreter

MOVN/MOVZ:
The first 12 lines are manually written tests, and then follows tests generated by a python script.
For program generated tests, the first six lines assign a random number to six registers
Next 26 lines test MOVN and MOVZ randomly with random pairs of registers on register 7-31
Next 31 lines test MOVN and MOVZ on all registers

OR/NOR/XOR/AND:
Next 26 lines are in the form LOGICAL $n, $n, $register(1-6). This will test for when MEM/WB and EX/MEM data hazards both occur, in which case the value from EX/MEM should be taken
Register n is checked after all instructions are run

ORI/XORI/ANDI:
First 4 lines assign random number to 4 registers. Next 50 lines test ORI, ANDI, XORI with random immediate numbers
The output registers are compared to the register values in MIPS interpreter

SLL/SRA/SRL:
6 lines generate random 16-bit numbers to assign to first 6 registers.
26 lines generate random 0<shamt<16 and applies a random shift (SLL, SRA, SRL) to a random register. 
The final registers are then compared to MIPS interpreter

SLT:
First 4 lines assign random numbers to 4 registers. Next 4 lines test SLTI/SLTIU manually with edge cases
The next 30 lines test SLTIU/SLTI with random immediate numbers
The output registers are compared to the register values in MIPS interpreter

SRLV/SRAV/SLLV:
6 Lines generate random unsigned numbers
26 Lines randomly generate pairs of first six registers and applies SRLV/SRAV/SLLV
Register values are compared to those from MIPS interpreter
Next 26 lines are in the form SHIFT $n, $(n-1), $(n-2). This will test for MEM/WB and EX/MEM data hazards INDEPENDENTLY
Register outputs are checked with MIPS interpreter
Next 26 lines are in the form SHIFT $n, $n, $register(1-6). This will test for when MEM/WB and EX/MEM data hazards both occur, in which case the value from EX/MEM should be taken
Register n is checked after all instructions are run

BRANCH/JUMP/LOAD/STORE:
Random integers are put into 31 registers. Then a random assortment of all the commands from project 3 (branch/load/jump/store) are inputted
The registered is checked to make sure the ADDIU values remain constant, that is instructions from project 3 do not affect the circuit

FINAL CHECK:
1000 lines to put random 32bit values into all registers using ADDIU, then a random command from all the ones given above. 
The final register after 1000 commands is compared to that from a MIPS interpreter to check for correctness